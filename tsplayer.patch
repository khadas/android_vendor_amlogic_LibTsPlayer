commit 2d3e538297216d4b2e97d2f50e7a53f4c872bfa1
Author: alex.cao <alex.cao@droid01-sz.amlogic.com>
Date:   Sat Nov 3 18:12:35 2012 +0800

    Add for tsplayer.so

diff --git a/CTC_MediaProcessor.cpp b/CTC_MediaProcessor.cpp
index 917eace..9c6ffb9 100755
--- a/CTC_MediaProcessor.cpp
+++ b/CTC_MediaProcessor.cpp
@@ -24,5 +24,5 @@ void DeleteMediaProcessor()
 
 int GetMediaProcessorVersion()
 {
-	return 1;
+	return 2;
 }
diff --git a/CTsPlayer.cpp b/CTsPlayer.cpp
index ed129f7..e5bcc74 100755
--- a/CTsPlayer.cpp
+++ b/CTsPlayer.cpp
@@ -12,6 +12,9 @@
 #define M_LIVE	1
 #define M_TVOD	2
 #define M_VOD	3
+#define RES_VIDEO_SIZE 256
+#define RES_AUDIO_SIZE 64
+#define UNIT_FREQ   96000
 
 #ifndef FBIOPUT_OSD_SRCCOLORKEY
 #define  FBIOPUT_OSD_SRCCOLORKEY    0x46fb
@@ -561,7 +564,7 @@ void LunchIptv()
     //Active_video_viewport(0,0,1280,720);
     set_sys_int("/sys/class/video/blackout_policy",0);
     //Active_osd_viewport(1280, 720);
-	set_sys_int("/sys/module/amvdec_h264/parameters/error_recovery_mode",3);
+	set_sys_int("/sys/module/amvdec_h264/parameters/error_recovery_mode",0);
 	
 
 
@@ -674,10 +677,7 @@ int SYS_disable_colorkey(void)
 
 CTsPlayer::CTsPlayer()
 {
-
-   
-
-	memset(&aPara,0,sizeof(aPara));
+	memset(a_aPara,0,sizeof(AUDIO_PARA_T)*MAX_AUDIO_PARAM_SIZE);
 	memset(&vPara,0,sizeof(vPara));
 	memset(&codec,0,sizeof(codec));
 	player_pid=-1;
@@ -690,6 +690,7 @@ CTsPlayer::CTsPlayer()
 	//set_sys_int("/sys/class/graphics/fb1/blank", 1);
 	//SetColorKey(1, 0);
 	m_bIsPlay = false;
+	pfunc_player_evt = NULL;
 	//SYS_set_global_alpha(100);
 	//SYS_disable_colorkey();
 	m_nOsdBpp = 16;//SYS_get_osdbpp();
@@ -698,6 +699,7 @@ CTsPlayer::CTsPlayer()
 	m_nVolume = 100;
 	m_bFast = false;
 	m_bSetEPGSize = false;
+	m_bWrFirstPkg = false;
 
 	m_nMode = M_LIVE;
 	//VideoHide();
@@ -711,10 +713,6 @@ CTsPlayer::CTsPlayer()
 
 CTsPlayer::~CTsPlayer()
 {
-
-
-
-
 		QuitIptv();
 }
 
@@ -772,13 +770,19 @@ int CTsPlayer::SetVideoWindow(int x,int y,int width,int height)
 
         return 0;
     	}
+    	
+   set_sys_str("/sys/class/graphics/fb0/video_hole","0 0 1280 720 0 8");
 
 	return 0 ;
 }
 
+int CTsPlayer::VideoShow(void)
+{
+	return 0;
+	//return set_sys_int("/sys/class/video/disable_video",0);
+}
 
-
-int CTsPlayer::SetColorKey(int enable,int key565)
+/*int CTsPlayer::SetColorKey(int enable,int key565)
 {
 
 
@@ -799,13 +803,9 @@ int CTsPlayer::SetColorKey(int enable,int key565)
         close(fd_fb0);
     }
     return ret;
-}
+}*/
+
 
-int CTsPlayer::VideoShow(void)
-{
-	return 0;
-	//return set_sys_int("/sys/class/video/disable_video",0);
-}
 int CTsPlayer::VideoHide(void)
 {
 	return 0;
@@ -815,44 +815,68 @@ int CTsPlayer::VideoHide(void)
 
 void CTsPlayer::InitVideo(PVIDEO_PARA_T pVideoPara)
 {
-
-
-
 	vPara=*pVideoPara;
+	__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "InitAudio vPara->pid:%d vPara->vFmt%d\n",vPara.pid,vPara.vFmt);
 	return ;
 }
 
 void CTsPlayer::InitAudio(PAUDIO_PARA_T pAudioPara)
 {
-
+    PAUDIO_PARA_T pAP = pAudioPara;
+	int count = 0;
 	__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "InitAudio");
-
-
-	aPara=*pAudioPara;
+    memset(a_aPara,0,sizeof(AUDIO_PARA_T)*MAX_AUDIO_PARAM_SIZE);
+	
+	while((pAP->pid != 0)
+		   &&(count<MAX_AUDIO_PARAM_SIZE))
+	{
+    a_aPara[count]= *pAP;
+    __android_log_print(ANDROID_LOG_INFO, "TsPlayer", "InitAudio pAP->pid:%d pAP->aFmt:%d\n",pAP->pid,pAP->aFmt);
+		pAP++;
+		count++;		
+	}
 	return ;
 }
 
 bool CTsPlayer::StartPlay()
 {
-
-
 	int ret;
+	
 	memset(pcodec,0,sizeof(*pcodec));
 	pcodec->stream_type=STREAM_TYPE_TS;
 	pcodec->video_type = vPara.vFmt;
 	pcodec->has_video=1;
-	pcodec->audio_type= aPara.aFmt;
+	pcodec->audio_type=a_aPara[0].aFmt;
+	
+	if ( pcodec->audio_type == 19)
+	{
+	   	pcodec->audio_type = AFORMAT_EAC3;
+	}
+	
+	if(IS_AUIDO_NEED_EXT_INFO(pcodec->audio_type))
+	{
+      pcodec->audio_info.valid = 1;
+      LOGI("set audio_info.valid to 1");
+  }
+
 	if (!m_bFast)
+	{
 		pcodec->has_audio=1;
+	  pcodec->audio_pid=(int)a_aPara[0].pid;
+	  pcodec->audio_samplerate=a_aPara[0].nSampleRate;	
+	  pcodec->audio_channels=a_aPara[0].nChannels;
+	  __android_log_print(ANDROID_LOG_INFO,"TsPlayer","pcodec->audio_samplerate:%d pcodec->audio_channels:%d\n",pcodec->audio_samplerate,pcodec->audio_channels);
+  }
+  
 	pcodec->video_pid=(int)vPara.pid;
-	pcodec->audio_pid=(int)aPara.pid;
 	//pcodec->noblock = 1;
 	 if (pcodec->video_type == VFORMAT_H264) {
         pcodec->am_sysinfo.format = VIDEO_DEC_FORMAT_H264;
         pcodec->am_sysinfo.param = (void *)(0);
     }
-	printf("set %d,%d,%d,%d\n",vPara.vFmt,aPara.aFmt,vPara.pid,aPara.pid);
+	__android_log_print(ANDROID_LOG_INFO,"TsPlayer","set %d,%d,%d,%d\n",vPara.vFmt,a_aPara[0].aFmt,vPara.pid,a_aPara[0].pid);
 	pcodec->noblock = 0;
+		
 	/*other setting*/
 	ret = codec_init(pcodec);
 	__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "StartPlay codec_init After:%d\n", ret);
@@ -866,26 +890,81 @@ bool CTsPlayer::StartPlay()
 		//m_fp = fopen("/data/Live.ts", "wb+");	
 #endif
 	}
+    m_bWrFirstPkg = true;
     set_sys_str("/sys/class/graphics/fb0/video_hole","0 0 1280 720 0 8");
 	return !ret;
 }
+
 int CTsPlayer::WriteData(unsigned char* pBuffer, unsigned int nSize)
 {	
 	int ret = -1;
+    buf_status audio_buf;
+	buf_status video_buf;
 
 	if (!m_bIsPlay)
 		return -1;
+    if(m_bWrFirstPkg == false)
+    {
+		
+	   codec_get_vbuf_state(pcodec,&audio_buf);
+	   codec_get_vbuf_state(pcodec,&video_buf);
+
+       if(pcodec->has_video)
+       {
+		   if(pcodec->video_type == VFORMAT_MJPEG)
+		   {
+               if(video_buf.data_len < (RES_VIDEO_SIZE >> 2))
+               {
+                  if(pfunc_player_evt != NULL)
+                  {
+                     pfunc_player_evt(IPTV_PLAYER_EVT_ABEND,player_evt_hander);
+				  }
+                  __android_log_print(ANDROID_LOG_INFO, "TsPlayer", "WriteData video low level\n");
+			   }
+		   }
+		   else
+		   {
+               if(video_buf.data_len< RES_VIDEO_SIZE)
+               {
+
+			      if(pfunc_player_evt != NULL)
+                  {
+                     pfunc_player_evt(IPTV_PLAYER_EVT_ABEND,player_evt_hander);
+				  }
+                  __android_log_print(ANDROID_LOG_INFO, "TsPlayer", "WriteData video low level\n");
+			   }
+		   }
+	   }
+
+	   if(pcodec->has_audio)
+       {
+           if(audio_buf.data_len < RES_AUDIO_SIZE)
+           {
+               if(pfunc_player_evt != NULL)
+               {
+                    pfunc_player_evt(IPTV_PLAYER_EVT_ABEND,player_evt_hander);
+			   }
+               __android_log_print(ANDROID_LOG_INFO, "TsPlayer", "WriteData audio low level\n");
+		   }
+	   }
+    }
 	
 	ret = codec_write(pcodec,pBuffer,nSize);
 	
-	if (ret > 0){
-#ifdef WF
-		if (m_fp != NULL){
+	if (ret > 0)
+	{
+    #ifdef WF
+		if (m_fp != NULL)
+		{
 			fwrite(pBuffer, 1, nSize, m_fp);
 		}
-#endif
+    #endif
+	  m_bWrFirstPkg = false;	
+	  __android_log_print(ANDROID_LOG_INFO, "TsPlayer", "codec_write return > 0\n");
 	}
-	else{
+	else
+	{
+		__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "codec_write return < 0\n");
 		return -1;
 	}
 	return ret;
@@ -918,8 +997,8 @@ bool CTsPlayer::Fast()
 		ret = set_sys_int("/sys/class/video/blackout_policy",0);
 	if (ret)
 		return false;
-	m_bFast = true;	
 	Stop();
+	m_bFast = true;	
 	ret = StartPlay();
 	if (!ret)
 		return false;
@@ -956,7 +1035,7 @@ bool CTsPlayer::Stop()
 
 
     
-
+  	int ret;
 	//if (m_nMode == M_LIVE)
 		//set_sys_int("/sys/class/video/blackout_policy",1);
     set_sys_str("/sys/class/graphics/fb0/video_hole","0 0 0 0 0 0");
@@ -967,9 +1046,12 @@ bool CTsPlayer::Stop()
 			m_fp = NULL;
 		}
 #endif
+
+    m_bFast = false;
+	  ret = codec_set_cntl_mode(pcodec, TRICKMODE_NONE);
 		__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "m_bIsPlay is true");
 		//codec_set_cntl_mode(pcodec, TRICKMODE_NONE);
-		int ret = codec_close(pcodec);
+		ret = codec_close(pcodec);
 		//codec_set_cntl_mode(pcodec, TRICKMODE_NONE);
 		__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "Stop  codec_close After:%d\n", ret);
 	}
@@ -987,7 +1069,7 @@ bool CTsPlayer::Stop()
 			SwitchResolution(1, 0);	
 		m_bSetEPGSize = false;
 	}
-	set_sys_str("/sys/class/graphics/fb0/video_hole","0 0 0 0 0 8");
+
 	return true;
 }
 bool CTsPlayer::Seek()
@@ -1040,10 +1122,13 @@ bool CTsPlayer::SetAudioBalance(int nAudioBalance)
 		return false;
 	m_nAudioBalance = nAudioBalance;
 	if (nAudioBalance == 1){
+		__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "SetAudioBalance 1\n");
 		codec_left_mono(pcodec);
 	}else if(nAudioBalance == 2){
+		__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "SetAudioBalance 2\n");
 		codec_right_mono(pcodec);
 	}else if(nAudioBalance == 3){
+		__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "SetAudioBalance 3\n");
 		codec_stereo(pcodec);
 	}
 	return true;
@@ -1052,7 +1137,7 @@ bool CTsPlayer::SetAudioBalance(int nAudioBalance)
 void CTsPlayer::GetVideoPixels(int& width, int& height)
 {
 
-	
+	/*
 	__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "GetVideoPixels");
 
 
@@ -1085,7 +1170,7 @@ void CTsPlayer::GetVideoPixels(int& width, int& height)
 			width = 1920;
 			height = 1080;
 		}
-	}
+	}*/
 }
 
 bool CTsPlayer::SetRatio(int nRatio)
@@ -1119,3 +1204,84 @@ void CTsPlayer::SetEPGSize(int w, int h)
 		m_bSetEPGSize = true;
 }
 
+void CTsPlayer::SwitchAudioTrack(int pid)
+{
+    int count = 0;
+  
+	while((a_aPara[count].pid != pid)
+		   &&(a_aPara[count].pid != 0)
+		   &&(count < MAX_AUDIO_PARAM_SIZE))
+  {
+       count++;
+	}
+	
+	codec_audio_automute(pcodec->adec_priv, 1);
+  codec_close_audio(pcodec);
+  pcodec->audio_pid = 0xffff;
+
+  if (codec_set_audio_pid(pcodec)) 
+  {
+        __android_log_print(ANDROID_LOG_INFO,"TsPlayer","set invalid audio pid failed\n");
+        return;
+  }
+  
+  if(count < MAX_AUDIO_PARAM_SIZE)
+  {
+  	 pcodec->has_audio=1;
+     pcodec->audio_type= a_aPara[count].aFmt;
+	   pcodec->audio_pid=(int)a_aPara[count].pid;
+	   pcodec->audio_samplerate=a_aPara[count].nSampleRate;	
+	   pcodec->audio_channels=a_aPara[count].nChannels;
+	}
+	__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "SwitchAudioTrack pcodec->audio_samplerate:%d pcodec->audio_channels:%d\n",pcodec->audio_samplerate,pcodec->audio_channels);
+	__android_log_print(ANDROID_LOG_INFO, "TsPlayer", "SwitchAudioTrack pcodec->audio_type:%d pcodec->audio_pid:%d\n",pcodec->audio_type,pcodec->audio_pid);
+  //codec_set_audio_pid(pcodec);
+  if(IS_AUIDO_NEED_EXT_INFO(pcodec->audio_type))
+	{
+      pcodec->audio_info.valid = 1;
+      LOGI("set audio_info.valid to 1");
+  }
+  
+  if (codec_audio_reinit(pcodec)) 
+  {
+      __android_log_print(ANDROID_LOG_INFO,"TsPlayer","reset init failed\n");
+      return;
+  }
+  
+  if (codec_reset_audio(pcodec)) 
+  {
+      __android_log_print(ANDROID_LOG_INFO,"TsPlayer","reset audio failed\n");
+      return;
+  }
+  codec_resume_audio(pcodec, 1);
+  codec_audio_automute(pcodec->adec_priv, 0);
+  
+  return ;
+}
+
+
+void CTsPlayer::SwitchSubtitle(int pid) 
+{
+}
+
+void CTsPlayer::SetProperty(int nType, int nSub, int nValue) 
+{
+
+}
+
+long CTsPlayer::GetCurrentPlayTime() 
+{
+    long video_pts = 0;
+    video_pts = codec_get_vpts(pcodec);
+	return video_pts;
+}
+void CTsPlayer::leaveChannel()
+{
+    Stop();
+}
+void CTsPlayer::playerback_register_evt_cb(IPTV_PLAYER_EVT_CB pfunc, void *hander)
+{
+    pfunc_player_evt = pfunc ;
+
+	player_evt_hander = hander;
+}
diff --git a/CTsPlayer.h b/CTsPlayer.h
index 8bb0909..5f54734 100755
--- a/CTsPlayer.h
+++ b/CTsPlayer.h
@@ -26,6 +26,7 @@ extern "C" {
 #define TRICKMODE_NONE       0x00
 #define TRICKMODE_I          0x01
 #define TRICKMODE_FFFB       0x02
+#define MAX_AUDIO_PARAM_SIZE 10
 typedef struct{
 	unsigned short	pid;//pid
 	int				nVideoWidth;//视频宽度
@@ -42,6 +43,17 @@ typedef struct{
 	int				nExtraSize;
 	unsigned char*	pExtraData;	
 }AUDIO_PARA_T, *PAUDIO_PARA_T;
+typedef enum
+{
+    IPTV_PLAYER_EVT_STREAM_VALID=0,
+    IPTV_PLAYER_EVT_FIRST_PTS,   //解出第一帧
+    IPTV_PLAYER_EVT_VOD_EOS,    //VOD播放完毕
+    IPTV_PLAYER_EVT_ABEND,         //为上报下溢事件而增加的类型
+    IPTV_PLAYER_EVT_PLAYBACK_ERROR,	// 播放错误
+}IPTV_PLAYER_EVT_e;
+
+typedef void (*IPTV_PLAYER_EVT_CB)(IPTV_PLAYER_EVT_e evt, void *handler);
+
 
 int enable_gl_2xscale(const char *);
 
@@ -95,8 +107,14 @@ public:
 	virtual void GetVideoPixels(int& width, int& height)=0;
 	virtual bool IsSoftFit()=0;
 	virtual void SetEPGSize(int w, int h)=0;
+	
 	//16位色深需要设置colorkey来透出视频；
-	virtual int  SetColorKey(int enable,int key565)=0;
+     virtual void SwitchAudioTrack(int pid) = 0;
+     virtual void SwitchSubtitle(int pid) = 0;
+     virtual void SetProperty(int nType, int nSub, int nValue) = 0;
+     virtual long GetCurrentPlayTime() = 0;
+     virtual void leaveChannel() = 0;
+	virtual void playerback_register_evt_cb(IPTV_PLAYER_EVT_CB pfunc, void *hander) = 0;
 };
 
 class CTsPlayer : public ITsPlayer
@@ -148,10 +166,25 @@ public:
 	virtual void GetVideoPixels(int& width, int& height);
 	virtual bool IsSoftFit();
 	virtual void SetEPGSize(int w, int h);
+
 	//16位色深需要设置colorkey来透出视频；
-	virtual int  SetColorKey(int enable,int key565);
+
+    virtual void SwitchAudioTrack(int pid) ;
+
+    virtual void SwitchSubtitle(int pid) ;
+    
+    virtual void SetProperty(int nType, int nSub, int nValue) ;
+    
+    virtual long GetCurrentPlayTime() ;
+    
+    virtual void leaveChannel() ;
+	virtual void playerback_register_evt_cb(IPTV_PLAYER_EVT_CB pfunc, void *hander);
+	
+protected:
+	int		m_bLeaveChannel;
+	
 private:
-	AUDIO_PARA_T aPara;
+	AUDIO_PARA_T a_aPara[MAX_AUDIO_PARAM_SIZE];
 	VIDEO_PARA_T vPara;	
 	int player_pid;
 	codec_para_t codec;
@@ -164,10 +197,14 @@ private:
 	int 	m_nEPGHeight;
 	bool	m_bFast;
 	bool 	m_bSetEPGSize;
+    bool    m_bWrFirstPkg;
 	int	m_nMode;
+    IPTV_PLAYER_EVT_CB pfunc_player_evt;
+    void *player_evt_hander;
 #ifdef WF
 	FILE*	m_fp;
 #endif
 
 };
+
 #endif
